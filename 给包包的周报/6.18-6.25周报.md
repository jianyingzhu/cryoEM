针对之前的神经网络区分实际带噪声的残差的低正确率，猜测神经网络表现差的原因是因为过度拟合了背景的噪声。一个很自然的想法是去除残差的背景进行训练。
残差为$A_ix-b_i=T_iC_iP_ix-b_i$，现有的mask是针对三维model的。我们带入的x是ground truth的三维结构（不带噪声）与带噪声的真实投影图像$b_i$。问题在于mask该怎么加？只能针对三维结构加mask，而$x$是无噪声的。
简单的做一个实验：在带噪声的残差$Ax-b$上加一个圆盘mask，简单的取每个残差中心三分之一的圆盘，其余元素置$0$。观察针对这样的残差训练的神经网络正确率能否有些许提升。
取每个残差中心三分之一的圆盘，其余元素置$0$这一步这样实现，但运行速度很慢，3W的数据原先只需要二十分钟，现在需要一个小时以上。
```python
# delete outer 2/3 background
for i in range(m):
    for j in range(m):
        if (i - round(m / 2)) ** 2 + (j - round(m / 2)) ** 2 > m ** 2 / 36:
            res[:, i, j] = 0
```
考虑用slice对numpy ndarray整体实现。经过询问张起，可以做一个mask，然后一张残差乘一下（逐元素），一个循环就够了。这样的话用numpy实现两个同类型数组的逐元素乘比自己用for循环快，因为numpy的底层用的C/Fortran/Cuda C写的，一个用python写的，差几千倍的速度很正常。上段代码现在改为：
```python
# delete outer 2/3 background
# generate one mask
mask = np.zeros((n, n))
for i in range(n):
    for j in range(n):
        if (i - round(n / 2)) ** 2 + (j - round(n / 2)) ** 2 <= n ** 2 / 36:
            mask[i, j] = 1
for k in range(m):
    res[k, :, :] = res[k, :, :] * mask
```



