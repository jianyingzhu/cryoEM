wait to do:
1. 在CRS上写这次mask的实验记录
1. 可视化神经网络
1. radius半径改为一致
1. 代码的print语句太乱了，整理
1. 为什么之前的错误网络是99.75正确率？两张图片就应该是50%或100%？代码还有其他问题吗？
1. 检查目前用下标实现的k fold的代码
2. 读Deep align论文，下周汇报
3. 读别人deep learning论文，看别人怎么preprocess，怎么处理强噪声
5. 调整网络结构？resnet研究（可以等回家再搞这部分，不需要问张起），手写resnet(不调用pytorch的源码)
6. mnist只给偶数样本，要求区分奇偶样本；GAN中有错误样本（人脸中混入了狗脸）能否生成人脸的类似问题调研。min-max：最大化不同类间距离，最小化样本内距离。使得类内点距离尽可能大以防止坍塌——可以产生loss函数。关键词：positive unlabeled learning, open set recognition


- 做如下实验：
假设三维的mask是 $m a s k_{3 d}$, 那么残差 $A_{i} x-b_{i}=T_{i} C_{i} P_{i} x-b_{i}$ 添加的 $m a s k_{2 d}$ 为： $m a s k_{3 d}$ 沿着 $P_{i}$ 投影得到二维 $m a s k$, 读取其距离中心点的最长半径 $R$, 添加以 $R$ 为半径的圆盘形mask，记为$mask_{2 d}$ 。
三维maskmas $k_{3 d}$ 这样设置：下载三维gound truth的model, 用chimera设置一个看起来好的间值, 读取model的时候把间值之上的置1，间值之下的置0。
- 得到结果：对不同的投影角添加mask后，经历5轮epoch，网络的正确率约为95%。
- 组会时提到，不需要这样设置与投影角相关的mask，应该设置半径一致的圆盘。
实验笔记：
- 自己手动生成一个mask：下载model，用chimera设置一个看起来好的阈值，程序里读model的时候把阈值之上的置1，阈值之下的置0就是一个mask。
- 自己选取的阈值：
cng  0.0196
fun30  0.0095
proteasome 0.0027
- .mrc文件是一个大数组，阈值图是它的显示方式：手动设定一个阈值，显示高于阈值的部分。使用阈值图显示.mrc是业界的一个共识，阈值有具体的物理学含义（电子云密度）。
- Volume, Image, Stack输入data新建时，默认convert_order = True，会进行中心与四周的翻转。
- 存成png: 
```python
from skimage.io import imsave
imsave(output_path + f'{protein}_proj.png', cp.asnumpy(img.data_RL))
```
- 在gpu00上运行小程序（大型计算任务不要这样操作），在gpu00上输入：（做了手动归一化，确认了shift/convert没有问题）
```python
python3
import numpy as np
a = np.memmap('fun30_10K_res.dat', dtype = np.float64, mode = 'r')
a = a.reshape((-1, 200, 200))
from skimage.io import imsave
imsave('fun30_res.png', a[0]) # 报错，因为gpu00上的skimage是老版本的，没做归一化
b = a[0].copy()
b.min() # -2.914956520539114
b.max() # 3.6979255476532775
b = (b - b.min()) / (b.max() - b.min())
b = (b * 255).astype(np.uint8)
imsave('fun30_masked_res.png', b)
exit()
```
- 在gpu00上最终输入以下代码，通过得到的png图片验证了添加的mask的正确性。
```python
import numpy as np
a = np.memmap('fun30_10K_res.dat', dtype = np.float64, mode = 'r')
a = a.reshape((-1, 200, 200))
from skimage.io import imsave
b = a[0].copy()
b = (b - b.min()) / (b.max() - b.min())
b = (b * 255).astype(np.uint8)
imsave('fun30_masked_res.png', b)

a = np.memmap('proteasome_10K_res.dat', dtype = np.float64, mode = 'r')
a = a.reshape((-1, 320, 320))
b = a[0].copy()
b = (b - b.min()) / (b.max() - b.min())
b = (b * 255).astype(np.uint8)
imsave('proteasome_masked_res.png', b)

a = np.memmap('cng_10K_res.dat', dtype = np.float64, mode = 'r')
a = a.reshape((-1, 160, 160))
b = a[0].copy()
b = (b - b.min()) / (b.max() - b.min())
b = (b * 255).astype(np.uint8)
imsave('cng_masked_res.png', b)
```




