TO DO:
2. resnet二分类训练集上损失函数应该接近0，网络未训练到位。调参。
3. cs231n补。
7. 尝试更多网络，更简单的网络更方便可视化。
8. DeepAlign论文。
9. 现在的程序没有问题，正确率可观，按照之前的想法继续往下做：调研open set recognition、positive unlabeled learning，复现结果并尝试运用于我们的问题。
10. 调研Deep Learning中对应问题：mnist只给偶数样本，要求区分奇偶样本；GAN中有错误样本（人脸中混入了狗脸）能否生成人脸。关键词：positive unlabeled learning, open set recognition
min-max：可以产生loss函数，最大化不同类间距离，最小化样本内距离，使得类内点距离尽可能大以防止坍塌。

#### 下周TO DO
0. 可视化的实验结果整理并上传CRS。
1. cs231n训练相关章节补，resnet二分类训练集上损失函数应该接近0，网络未训练到位，调参并汇报结果。
2. 尝试更多网络，更简单的网络更方便可视化。
3. 做神经网络可迁移性的实验。

- 问题: recon_select的随机性到底在哪里？解答：加`torch.random.manual_seed(0)`
1. 
```python
np.random.seed(0) #不会固定torch.randn
print(torch.randn(4, dtype = torch.float64))
```
2. random seed保证每次执行文件都获得一样的结果，而同一个.py文件内会获得不一样的结果。
```python
np.random.seed(0)
print(np.random.rand())
print(np.random.rand())
print(np.random.rand())
'''
0.5488135039273248
0.7151893663724195
0.6027633760716439
'''
```
3. 一个.py文件import另一个.py文件后，相当于打开它并调用两次。
```python
# try1.py
class rand(object):
    def __init__(self):
        self.rand = torch.randn(4, dtype = torch.float64)
    def show_rand(self):
        print(self.rand)
# try.py
from try1 import rand

a = rand()
b = rand()
a.show_rand()
b.show_rand()
'''
tensor([ 1.5410, -0.2934, -2.1788,  0.5684], dtype=torch.float64)
tensor([-1.0845, -1.3986,  0.4033,  0.8380], dtype=torch.float64)
'''
```
- torch.Tensor.permute(): *dims (int...) – The desired ordering of dimensions
- 